---
phase: 10-client-boundary-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - components/marquee-text.tsx
  - components/animated-counter.tsx
  - app/globals.css
autonomous: true

must_haves:
  truths:
    - "MarqueeText scrolls text infinitely using CSS animation with no framer-motion dependency"
    - "MarqueeText has no 'use client' directive and renders as a server component"
    - "MarqueeText direction prop controls whether text scrolls left-to-right or right-to-left"
    - "AnimatedCounter only starts counting when the element scrolls into the viewport (not on mount)"
    - "AnimatedCounter still counts up from 0 to the target value with the same 2-second duration"
  artifacts:
    - path: "components/marquee-text.tsx"
      provides: "Server-compatible marquee with CSS animation"
      contains: "marquee-scroll"
    - path: "components/animated-counter.tsx"
      provides: "Client component with Intersection Observer visibility trigger"
      contains: "IntersectionObserver"
    - path: "app/globals.css"
      provides: "CSS marquee animation keyframes"
      contains: "@keyframes marquee-scroll"
  key_links:
    - from: "components/marquee-text.tsx"
      to: "app/globals.css"
      via: "CSS animation reference"
      pattern: "marquee-scroll"
    - from: "components/animated-counter.tsx"
      to: "IntersectionObserver API"
      via: "Browser API for visibility detection"
      pattern: "IntersectionObserver"
---

<objective>
Convert MarqueeText from framer-motion to pure CSS animation (enabling server component rendering) and add Intersection Observer to AnimatedCounter so it animates on visibility rather than on mount.

Purpose: MarqueeText uses framer-motion only for a simple infinite translate animation that CSS handles natively. Converting it removes the "use client" requirement. AnimatedCounter currently starts counting immediately on mount, which means metrics animate even before the user scrolls to them -- Intersection Observer makes the animation meaningful by triggering when visible.

Output: MarqueeText as a server component with CSS animation. AnimatedCounter with visibility-triggered counting via Intersection Observer.
</objective>

<execution_context>
@/Users/sunny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@components/marquee-text.tsx
@components/animated-counter.tsx
@app/globals.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert MarqueeText from framer-motion to CSS animation</name>
  <files>components/marquee-text.tsx, app/globals.css</files>
  <action>
    Replace framer-motion infinite translate animation with pure CSS.

    In `app/globals.css`, add at the end:
    ```css
    /* Marquee text animation */
    @keyframes marquee-scroll {
      from { transform: translateX(0); }
      to { transform: translateX(-50%); }
    }
    ```

    In `components/marquee-text.tsx`:
    1. Remove `"use client"` directive
    2. Remove `import { motion } from "framer-motion"`
    3. Replace the `<motion.div>` with a regular `<div>`
    4. Apply CSS animation via inline style

    The current framer-motion implementation:
    ```tsx
    <motion.div
      animate={{ x: direction > 0 ? ["0%", "-50%"] : ["-50%", "0%"] }}
      transition={{ duration: 20, repeat: Infinity, ease: "linear" }}
      className="inline-flex"
    >
    ```

    Replace with CSS animation. For `direction > 0` (default, left-scrolling):
    - Animation: `marquee-scroll 20s linear infinite`

    For `direction < 0` (right-scrolling, used by bottom marquee):
    - Animation: `marquee-scroll 20s linear infinite reverse`

    The converted component should look like:
    ```tsx
    export type MarqueeTextProps = {
      text: string;
      direction?: number;
    };

    export function MarqueeText({ text, direction = 1 }: MarqueeTextProps) {
      return (
        <div className="overflow-hidden whitespace-nowrap">
          <div
            className="inline-flex"
            style={{
              animation: `marquee-scroll 20s linear infinite${direction > 0 ? "" : " reverse"}`,
            }}
          >
            {[...Array(4)].map((_, i) => (
              <span key={i} className="mx-4">
                {text}
              </span>
            ))}
          </div>
        </div>
      );
    }
    ```

    Why this works: The framer-motion animation was `x: ["0%", "-50%"]` with `repeat: Infinity, ease: "linear"` -- that is literally CSS `translateX(0) -> translateX(-50%)` on infinite repeat with linear timing. For reverse direction, CSS `animation-direction: reverse` achieves the same as `x: ["-50%", "0%"]`. The 4 repeated spans create a seamless loop when translating by -50%.

  </action>
  <verify>
    1. `grep -c "use client" components/marquee-text.tsx` returns 0
    2. `grep -c "framer-motion" components/marquee-text.tsx` returns 0
    3. `grep -c "motion\." components/marquee-text.tsx` returns 0
    4. `grep "@keyframes marquee-scroll" app/globals.css` finds the animation
    5. `npm run build` succeeds with no errors
  </verify>
  <done>MarqueeText is a server component with no "use client", no framer-motion. Scrolling text animates via CSS @keyframes. Direction prop works (normal for left-scroll, reverse for right-scroll). Visual behavior matches the framer-motion version exactly.</done>
</task>

<task type="auto">
  <name>Task 2: Add Intersection Observer to AnimatedCounter for visibility-triggered animation</name>
  <files>components/animated-counter.tsx</files>
  <action>
    Add Intersection Observer so the counter only starts counting when the element becomes visible in the viewport.

    In `components/animated-counter.tsx`:
    1. Keep `"use client"` directive (this component genuinely needs client APIs: useState, useEffect, useRef, IntersectionObserver)
    2. Add `useRef` to the imports (already has useState, useEffect)
    3. Add a `ref` to the outermost `<span>` element
    4. Add a `isVisible` state (default `false`)
    5. Add an IntersectionObserver effect that:
       - Creates an IntersectionObserver on the span ref
       - Sets `isVisible = true` when the element enters the viewport (threshold: 0.1)
       - Disconnects the observer once triggered (one-shot -- once visible, stays visible)
       - Cleans up on unmount
    6. Modify the counting useEffect to only run when `isVisible` is true:
       - Add `isVisible` to the dependency array
       - Guard: if `!isVisible` return early (don't start counting)
       - Reset count to 0 when starting (in case of re-renders)

    The updated component should look like:
    ```tsx
    "use client";

    import { useState, useEffect, useRef } from "react";

    export type AnimatedCounterProps = {
      value: string;
      suffix?: string;
    };

    export function AnimatedCounter({ value, suffix = "" }: AnimatedCounterProps) {
      const [count, setCount] = useState(0);
      const [isVisible, setIsVisible] = useState(false);
      const ref = useRef<HTMLSpanElement>(null);
      const numericValue = parseInt(value.replace(/\D/g, "")) || 0;

      // Observe visibility
      useEffect(() => {
        const el = ref.current;
        if (!el) return;

        const observer = new IntersectionObserver(
          ([entry]) => {
            if (entry.isIntersecting) {
              setIsVisible(true);
              observer.disconnect();
            }
          },
          { threshold: 0.1 },
        );

        observer.observe(el);
        return () => observer.disconnect();
      }, []);

      // Animate count when visible
      useEffect(() => {
        if (!isVisible) return;

        setCount(0);
        const duration = 2000;
        const steps = 60;
        const increment = numericValue / steps;
        let current = 0;
        const timer = setInterval(() => {
          current += increment;
          if (current >= numericValue) {
            setCount(numericValue);
            clearInterval(timer);
          } else {
            setCount(Math.floor(current));
          }
        }, duration / steps);
        return () => clearInterval(timer);
      }, [isVisible, numericValue]);

      return (
        <span ref={ref}>
          {value.startsWith("+") ? "+" : value.startsWith("-") ? "-" : ""}
          {count}
          {suffix}
        </span>
      );
    }
    ```

    Why keep "use client": AnimatedCounter genuinely needs client-side execution -- useState for count state, useEffect for timer/observer, useRef for DOM reference, IntersectionObserver browser API. This component must remain a client component.

    Why Intersection Observer over scroll listeners: IO is more performant (browser-optimized, no layout thrashing), one-shot (disconnect after first trigger), and is the standard pattern for "animate when visible" behavior.

  </action>
  <verify>
    1. `grep -c "IntersectionObserver" components/animated-counter.tsx` returns at least 1
    2. `grep -c "isVisible" components/animated-counter.tsx` returns at least 2
    3. `grep -c "observer.disconnect" components/animated-counter.tsx` returns at least 1
    4. `grep "useRef" components/animated-counter.tsx` confirms useRef is imported
    5. `npm run build` succeeds with no errors
  </verify>
  <done>AnimatedCounter uses Intersection Observer to detect viewport entry. Counter animation starts only when the element becomes visible (not on mount). Observer disconnects after first trigger (one-shot). 2-second counting animation and visual appearance are unchanged.</done>
</task>

</tasks>

<verification>
Run all checks in sequence:

```bash
# 1. MarqueeText is a server component
grep -c "use client" components/marquee-text.tsx       # expect: 0
grep -c "framer-motion" components/marquee-text.tsx    # expect: 0

# 2. CSS animation exists
grep "@keyframes marquee-scroll" app/globals.css       # expect: match

# 3. AnimatedCounter has Intersection Observer
grep -c "IntersectionObserver" components/animated-counter.tsx  # expect: >= 1
grep -c "isVisible" components/animated-counter.tsx             # expect: >= 2

# 4. AnimatedCounter still has "use client" (it needs it)
grep -c "use client" components/animated-counter.tsx   # expect: 1

# 5. Build passes
npm run build
```

</verification>

<success_criteria>

- components/marquee-text.tsx has no "use client", no framer-motion, uses CSS animation
- Marquee direction prop works: default scrolls left, direction={-1} scrolls right (via CSS reverse)
- app/globals.css contains @keyframes marquee-scroll
- components/animated-counter.tsx uses IntersectionObserver to trigger counting on visibility
- AnimatedCounter keeps "use client" (genuinely needs client APIs)
- `npm run build` passes with no errors
- Both marquees scroll at same speed (20s duration) as before
- Counter animation still takes 2 seconds and counts from 0 to target value
  </success_criteria>

<output>
After completion, create `.planning/phases/10-client-boundary-extraction/10-02-SUMMARY.md`
</output>
