---
phase: 10-client-boundary-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/twinkling-stars.tsx
  - components/css-preloader.tsx
  - components/graph-legend.tsx
  - app/globals.css
autonomous: true

must_haves:
  truths:
    - "Twinkling-stars renders identically but has no 'use client' directive and no React hooks"
    - "CSS-preloader renders identically but has no 'use client' directive"
    - "Graph-legend renders identically with a CSS entrance animation instead of framer-motion"
    - "No framer-motion import exists in twinkling-stars.tsx, css-preloader.tsx, or graph-legend.tsx"
  artifacts:
    - path: "components/twinkling-stars.tsx"
      provides: "Server-compatible twinkling stars with CSS animation"
      contains: "mulberry32"
    - path: "components/css-preloader.tsx"
      provides: "Server component preloader"
    - path: "components/graph-legend.tsx"
      provides: "Server component graph legend with CSS entrance"
    - path: "app/globals.css"
      provides: "twinkle keyframe animation and graph-legend entrance animation"
      contains: "@keyframes twinkle"
  key_links:
    - from: "components/twinkling-stars.tsx"
      to: "app/globals.css"
      via: "CSS animation reference"
      pattern: "animation.*twinkle"
    - from: "components/graph-legend.tsx"
      to: "app/globals.css"
      via: "CSS animation class"
      pattern: "animate-"
---

<objective>
Convert three pure-static components from client to server components by removing unnecessary "use client" directives, React hooks, and framer-motion dependencies.

Purpose: These components (twinkling-stars, css-preloader, graph-legend) have no genuine need for client-side execution. Removing their client boundary reduces the JS bundle sent to the browser and prepares them for Phase 11 where page.tsx becomes a server component.

Output: Three server-compatible components with no "use client" directive, no React hooks, and no framer-motion imports. All visual behavior preserved via CSS animations.
</objective>

<execution_context>
@/Users/sunny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-server-side-github-fetching/09-01-SUMMARY.md
@components/twinkling-stars.tsx
@components/css-preloader.tsx
@components/graph-legend.tsx
@app/globals.css
@lib/seeded-random.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert TwinklingStars to server component</name>
  <files>components/twinkling-stars.tsx, app/globals.css</files>
  <action>
    Convert TwinklingStars from a client component with useMemo to a server component with module-level computation.

    In `components/twinkling-stars.tsx`:
    1. Remove `"use client"` directive from line 1
    2. Remove the `import { useMemo } from "react"` import
    3. Move the star generation logic OUT of the component body and OUT of useMemo, making it a module-level constant. The star generation already uses a seeded PRNG (mulberry32 with seed 42), so it produces identical output every call -- no need for useMemo memoization:
       ```typescript
       const random = mulberry32(42);
       const STAR_COUNT = 50;
       const stars: Star[] = [];
       // ... same generation logic currently inside useMemo callback ...
       ```
    4. Simplify the component to just render the pre-computed `stars` array (remove useMemo wrapper)
    5. Remove the inline `<style>` block that defines `@keyframes twinkle` -- move it to globals.css instead

    In `app/globals.css`:
    6. Add the `@keyframes twinkle` animation at the end of the file (after existing preloader animations):
       ```css
       /* Twinkling stars animation */
       @keyframes twinkle {
         0%, 100% { opacity: var(--star-base-opacity); }
         50% { opacity: var(--star-peak-opacity); }
       }
       ```

    Why module-level instead of useMemo: The seeded PRNG produces deterministic output -- calling mulberry32(42) always returns the same sequence. Module-level execution runs once at import time on the server, which is the same as useMemo(fn, []) in a client component. This eliminates the React hook dependency entirely.

    Why move @keyframes to globals.css: Inline `<style>` tags in React components cause hydration warnings in server components and duplicate the CSS on every render. globals.css is the existing location for keyframe animations (preloader-fade-in, preloader-step-fade, etc.).

  </action>
  <verify>
    1. `grep -c "use client" components/twinkling-stars.tsx` returns 0
    2. `grep -c "useMemo\|useState\|useEffect" components/twinkling-stars.tsx` returns 0
    3. `grep -c "framer-motion" components/twinkling-stars.tsx` returns 0
    4. `grep "@keyframes twinkle" app/globals.css` finds the animation
    5. `grep -c "<style>" components/twinkling-stars.tsx` returns 0
    6. `npm run build` succeeds with no errors
  </verify>
  <done>TwinklingStars is a server component: no "use client", no hooks, no inline styles. Stars are computed at module level using seeded PRNG. The twinkle animation is defined in globals.css. Visual output is identical (same seed, same positions, same animation timing).</done>
</task>

<task type="auto">
  <name>Task 2: Convert CSSPreloader and GraphLegend to server components</name>
  <files>components/css-preloader.tsx, components/graph-legend.tsx, app/globals.css</files>
  <action>
    **CSSPreloader** (trivial conversion):

    In `components/css-preloader.tsx`:
    1. Remove `"use client"` directive from line 1
    2. That's it -- no other changes needed. CSSPreloader uses no React hooks, no browser APIs, no framer-motion. It only imports RESUME_DATA (static data) and uses CSS animations already defined in globals.css.

    **GraphLegend** (replace framer-motion with CSS):

    In `app/globals.css`:
    1. Add a CSS entrance animation for graph-legend at the end of the file:
       ```css
       /* Graph legend entrance animation */
       @keyframes legend-slide-in {
         from {
           opacity: 0;
           transform: translateX(-20px);
         }
         to {
           opacity: 1;
           transform: translateX(0);
         }
       }
       ```

    In `components/graph-legend.tsx`:
    2. Remove `"use client"` directive
    3. Remove the `import { motion } from "framer-motion"` import
    4. Replace the outer `<motion.div>` element with a regular `<div>` element
    5. Remove the framer-motion props: `initial`, `whileInView`, `viewport`, `transition`
    6. Add CSS animation to the `<div>`: add `style={{ animation: "legend-slide-in 0.5s ease-out forwards" }}` to the existing className/style
    7. Keep all existing className and children unchanged

    The converted div should look like:
    ```tsx
    <div
      className="rounded-lg border border-stone-800/50 bg-stone-950/80 p-4 shadow-xl backdrop-blur-sm max-w-[200px] opacity-80 hover:opacity-100 transition-opacity"
      style={{ animation: "legend-slide-in 0.5s ease-out forwards" }}
    >
    ```

    Note: The original framer-motion `whileInView` triggered animation on viewport entry. The CSS replacement triggers on render. This is acceptable because the graph-legend is only rendered inside GraphSection which loads via dynamic import (ssr: false) -- it only mounts when the user has scrolled to the graph area. The visual effect is equivalent.

  </action>
  <verify>
    1. `grep -c "use client" components/css-preloader.tsx` returns 0
    2. `grep -c "use client" components/graph-legend.tsx` returns 0
    3. `grep -c "framer-motion" components/graph-legend.tsx` returns 0
    4. `grep -c "motion\." components/graph-legend.tsx` returns 0
    5. `grep "@keyframes legend-slide-in" app/globals.css` finds the animation
    6. `npm run build` succeeds with no errors
  </verify>
  <done>CSSPreloader has no "use client" directive (was the only change needed). GraphLegend has no "use client", no framer-motion import, and uses CSS animation for entrance effect. Both render identically.</done>
</task>

</tasks>

<verification>
Run all checks in sequence:

```bash
# 1. No "use client" in converted components
grep -c "use client" components/twinkling-stars.tsx  # expect: 0
grep -c "use client" components/css-preloader.tsx     # expect: 0
grep -c "use client" components/graph-legend.tsx      # expect: 0

# 2. No React hooks in converted components
grep -c "useMemo\|useState\|useEffect\|useRef\|useCallback" components/twinkling-stars.tsx  # expect: 0
grep -c "useMemo\|useState\|useEffect\|useRef\|useCallback" components/graph-legend.tsx     # expect: 0

# 3. No framer-motion in converted components
grep -c "framer-motion" components/twinkling-stars.tsx  # expect: 0
grep -c "framer-motion" components/css-preloader.tsx     # expect: 0
grep -c "framer-motion" components/graph-legend.tsx      # expect: 0

# 4. CSS animations exist in globals.css
grep "@keyframes twinkle" app/globals.css           # expect: match
grep "@keyframes legend-slide-in" app/globals.css   # expect: match

# 5. Build passes
npm run build
```

</verification>

<success_criteria>

- components/twinkling-stars.tsx has no "use client", no hooks, no inline `<style>`, uses module-level star generation
- components/css-preloader.tsx has no "use client" directive
- components/graph-legend.tsx has no "use client", no framer-motion, uses CSS animation for entrance
- app/globals.css contains @keyframes twinkle and @keyframes legend-slide-in
- `npm run build` passes with no errors
- Visual appearance of all three components is unchanged
  </success_criteria>

<output>
After completion, create `.planning/phases/10-client-boundary-extraction/10-01-SUMMARY.md`
</output>
