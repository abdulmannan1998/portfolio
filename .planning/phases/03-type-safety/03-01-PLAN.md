---
phase: 03-type-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/layout-calculator.ts
  - lib/stores/graph-store.tsx
  - components/nodes/achievement-node.tsx
autonomous: true

must_haves:
  truths:
    - "TypeScript compiler catches invalid node type access"
    - "Achievement node data has strictly typed properties"
    - "Graph store state is JSON-serializable"
  artifacts:
    - path: "lib/layout-calculator.ts"
      provides: "Discriminated union GraphNode type"
      contains: "type: 'root' | 'company' | 'education' | 'soft-skill' | 'achievement'"
    - path: "lib/layout-calculator.ts"
      provides: "AchievementNodeDisplayData type"
      contains: "interface AchievementNodeDisplayData"
    - path: "lib/stores/graph-store.tsx"
      provides: "Serializable expandedNodes state"
      contains: "expandedNodes: string[]"
  key_links:
    - from: "lib/layout-calculator.ts"
      to: "components/nodes/achievement-node.tsx"
      via: "AchievementNodeDisplayData type match"
      pattern: "AchievementNodeDisplayData"
    - from: "lib/stores/graph-store.tsx"
      to: "components/nodes/achievement-node.tsx"
      via: "expandedNodes array methods"
      pattern: "expandedNodes\\.includes"
---

<objective>
Fix type safety issues in the portfolio codebase by replacing implicit any types with discriminated unions and making the graph store serializable.

Purpose: TypeScript should catch data shape errors at compile time instead of runtime. This prevents bugs when refactoring and improves IDE autocompletion.

Output: Type-safe layout calculator, strict achievement data type, serializable graph store state.
</objective>

<execution_context>
@/Users/sunny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/layout-calculator.ts
@lib/stores/graph-store.tsx
@components/nodes/achievement-node.tsx
@data/resume-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create discriminated union for GraphNode type</name>
  <files>lib/layout-calculator.ts</files>
  <action>
Replace the loose GraphNode type (currently uses `[key: string]: any`) with a discriminated union type that properly represents all node variants:

1. Define base node type with common fields: `id: string`
2. Create specific interfaces for each node type:
   - `RootNodeData`: type: 'root', label: string
   - `CompanyNodeData`: type: 'company', label: string, period?: string
   - `EducationNodeData`: type: 'education', label: string, period?: string
   - `SoftSkillNodeData`: type: 'soft-skill', label: string
   - `AchievementNodeData`: type: 'achievement', title: string, description: string, impact: string, technologies: string[], company: string, category: AchievementCategory

3. Define GraphNode as union of all node types:
   `type GraphNode = RootNodeData | CompanyNodeData | EducationNodeData | SoftSkillNodeData | AchievementNodeData`

4. Remove the `// eslint-disable-next-line @typescript-eslint/no-explicit-any` comment and the `[key: string]: any` index signature

5. Update references to use type guards where needed (e.g., `node.type === 'achievement'` narrows to AchievementNodeData)

Import AchievementCategory from @/data/resume-data if needed for the achievement node type.
</action>
<verify>
Run `npx tsc --noEmit` - should pass with no errors related to GraphNode type.
Verify the discriminated union narrows correctly in getTimelinePositions function.
</verify>
<done>
GraphNode type is a proper discriminated union. No any types remain in the type definition. TypeScript narrows node types based on node.type checks.
</done>
</task>

<task type="auto">
  <name>Task 2: Create strict AchievementNodeDisplayData type</name>
  <files>lib/layout-calculator.ts, components/nodes/achievement-node.tsx</files>
  <action>
Create a strict interface for the data passed to AchievementNode component:

1. In lib/layout-calculator.ts, define AchievementNodeDisplayData interface with exactly the fields the component needs:

   ```typescript
   export interface AchievementNodeDisplayData {
     id: string;
     title: string;
     description: string;
     impact: string;
     technologies: string[];
     company: string;
     category: AchievementCategory;
     animationDelay?: number;
     animationType?: string;
   }
   ```

2. Export this type so achievement-node.tsx can import it

3. Update the node creation in getTimelinePositions to explicitly construct AchievementNodeDisplayData instead of spreading `...achievement` which includes extra properties:

   ```typescript
   data: {
     id: achievement.id,
     title: achievement.title,
     description: achievement.description,
     impact: achievement.impact,
     technologies: achievement.technologies,
     company: achievement.company,
     category: achievement.category,
     animationDelay: ...,
     animationType: 'fade-drop',
   } satisfies AchievementNodeDisplayData,
   ```

4. In components/nodes/achievement-node.tsx, import AchievementNodeDisplayData from lib/layout-calculator and use it:

   ```typescript
   import { AchievementNodeDisplayData } from "@/lib/layout-calculator";

   type AchievementNodeProps = {
     id: string;
     data: AchievementNodeDisplayData;
     selected: boolean;
   };
   ```

This ensures the component's data prop matches exactly what layout-calculator provides.
</action>
<verify>
Run `npx tsc --noEmit` - should pass with no errors.
Check that achievement-node.tsx has no inline type definition for data prop.
</verify>
<done>
AchievementNodeDisplayData is defined once in layout-calculator.ts and imported by achievement-node.tsx. The data prop is strictly typed with no any escape hatches.
</done>
</task>

<task type="auto">
  <name>Task 3: Replace Set with array in graph store</name>
  <files>lib/stores/graph-store.tsx, components/nodes/achievement-node.tsx</files>
  <action>
Replace Set<string> with string[] for expandedNodes to make state JSON-serializable:

1. In lib/stores/graph-store.tsx, change the state type:

   ```typescript
   type GraphState = {
     expandedNodes: string[];
     expandNode: (id: string) => void;
     collapseNode: (id: string) => void;
     collapseAll: () => void;
   };
   ```

2. Update initial state:

   ```typescript
   expandedNodes: [],
   ```

3. Update expandNode action to add to array (prevent duplicates):

   ```typescript
   expandNode: (id) =>
     set((state) => ({
       expandedNodes: state.expandedNodes.includes(id)
         ? state.expandedNodes
         : [...state.expandedNodes, id],
     })),
   ```

4. Update collapseNode action to filter from array:

   ```typescript
   collapseNode: (id) =>
     set((state) => ({
       expandedNodes: state.expandedNodes.filter((nodeId) => nodeId !== id),
     })),
   ```

5. Update collapseAll to reset to empty array:

   ```typescript
   collapseAll: () => set({ expandedNodes: [] }),
   ```

6. In achievement-node.tsx, update the Set check to array check:
   ```typescript
   // Before: expandedNodes.has(data.id)
   // After: expandedNodes.includes(data.id)
   const isExpanded = expandedNodes.includes(data.id);
   ```

Note: Array includes() is O(n) vs Set.has() O(1), but for <50 nodes this is negligible. Serialization is more important than micro-optimization.
</action>
<verify>
Run `npx tsc --noEmit` - should pass with no errors.
Run `npm run dev`, expand an achievement node - verify expand/collapse still works.
Verify state is serializable: `JSON.stringify(useGraphStore.getState())` should work.
</verify>
<done>
expandedNodes is a string array. All Set methods (.has, .add, .delete) replaced with array equivalents (.includes, spread, .filter). State is JSON-serializable.
</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. No `any` types remain in layout-calculator.ts (except necessary library types)
3. Achievement nodes expand/collapse correctly in browser
4. Graph store state is JSON-serializable: `JSON.stringify(useGraphStore.getState())` works
</verification>

<success_criteria>

- TYPE-01: GraphNode uses discriminated union (no `[key: string]: any`)
- TYPE-02: AchievementNodeDisplayData is strict, shared between calculator and component
- TYPE-03: expandedNodes is string[] not Set<string>
- All TypeScript compilation passes
- Existing functionality unchanged
  </success_criteria>

<output>
After completion, create `.planning/phases/03-type-safety/03-01-SUMMARY.md`
</output>
