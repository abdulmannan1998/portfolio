---
phase: 12-ppr-image-optimization
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/use-hydrated.ts
  - components/sections/hero-section.tsx
  - components/sections/about-section.tsx
  - components/sections/metrics-section.tsx
  - components/sections/experience-timeline.tsx
  - components/sections/tech-stack-section.tsx
  - components/sections/graph-section.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "PPR static shell shows all section content visibly (opacity: 1) before JS loads"
    - "Entrance animations still play after hydration for below-fold sections when scrolled into view"
    - "Hero section content is visible in the prerendered HTML, not hidden behind opacity: 0"
    - "No perceptible flash of invisible content during hydration transition"
  artifacts:
    - path: "lib/use-hydrated.ts"
      provides: "Hydration detection hook"
      exports: ["useHydrated"]
    - path: "components/sections/hero-section.tsx"
      provides: "Hero with hydration-aware initial state"
      contains: "useHydrated"
    - path: "components/sections/about-section.tsx"
      provides: "About with hydration-aware initial state"
      contains: "useHydrated"
    - path: "components/sections/metrics-section.tsx"
      provides: "Metrics with hydration-aware initial state"
      contains: "useHydrated"
    - path: "components/sections/experience-timeline.tsx"
      provides: "Timeline with hydration-aware initial state"
      contains: "useHydrated"
    - path: "components/sections/tech-stack-section.tsx"
      provides: "Tech stack with hydration-aware initial state"
      contains: "useHydrated"
    - path: "components/sections/graph-section.tsx"
      provides: "Graph with hydration-aware initial state"
      contains: "useHydrated"
  key_links:
    - from: "components/sections/hero-section.tsx"
      to: "lib/use-hydrated.ts"
      via: "import { useHydrated }"
      pattern: "useHydrated"
    - from: "all section components"
      to: "lib/use-hydrated.ts"
      via: "import { useHydrated }"
      pattern: "useHydrated"
---

<objective>
Fix GAP-1: PPR static shell is visually empty because framer-motion sets inline `style="opacity: 0"` on all 12 motion elements during server rendering. Content must be visible in the prerendered HTML while preserving entrance animations after hydration.

Purpose: The entire point of PPR is to show content instantly. With all sections hidden behind opacity: 0, users see a blank page for 3-5s on slow networks until JS hydrates. This defeats PPR.

Output: All section components render with visible content in the static HTML shell. After hydration, entrance animations play normally for below-fold content. No visual regression.
</objective>

<execution_context>
@/Users/sunny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-ppr-image-optimization/12-VERIFICATION.md
@.planning/phases/12-ppr-image-optimization/12-01-SUMMARY.md
@components/sections/hero-section.tsx
@components/sections/about-section.tsx
@components/sections/metrics-section.tsx
@components/sections/experience-timeline.tsx
@components/sections/tech-stack-section.tsx
@components/sections/graph-section.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useHydrated hook and update all section components</name>
  <files>
    lib/use-hydrated.ts
    components/sections/hero-section.tsx
    components/sections/about-section.tsx
    components/sections/metrics-section.tsx
    components/sections/experience-timeline.tsx
    components/sections/tech-stack-section.tsx
    components/sections/graph-section.tsx
  </files>
  <action>
## Step 1: Create `lib/use-hydrated.ts`

Create a lightweight hydration detection hook:

```ts
import { useState, useEffect } from "react";

export function useHydrated(): boolean {
  const [hydrated, setHydrated] = useState(false);
  useEffect(() => {
    setHydrated(true);
  }, []);
  return hydrated;
}
```

This returns `false` during SSR and on the first client render, then `true` after the mount effect fires.

## Step 2: Apply hydration-aware `initial` + `key` pattern to all motion elements

The pattern is the same for every motion element. For each `motion.*` element that has an `initial={{ opacity: 0, ... }}` prop:

1. Import `useHydrated` from `@/lib/use-hydrated`
2. Call `const isHydrated = useHydrated();` at the top of the component
3. Change `initial` to be conditional: `initial={isHydrated ? { opacity: 0, y: 50 } : false}`
4. Add a `key` prop to force remount on hydration: `key={isHydrated ? "animated" : "static"}`

When `initial={false}`, framer-motion does NOT apply any initial inline styles. The server-rendered HTML has no `style="opacity: 0"`, so content is visible in the PPR shell.

When `isHydrated` becomes `true`, the `key` change causes React to unmount the old element and mount a new one with `initial={{ opacity: 0 }}`. Framer-motion then triggers the entrance animation via `animate` or `whileInView`. The remount takes a single frame (~16ms), imperceptible to users.

### Specific changes per component:

**hero-section.tsx** (3 elements):

- `motion.h1`: `initial={isHydrated ? { y: 100, opacity: 0 } : false}` + `key={isHydrated ? "animated" : "static"}`
- `motion.div` (orange bar): `initial={isHydrated ? { scaleX: 0 } : false}` + `key={isHydrated ? "animated" : "static"}`
- `motion.p` (subtitle): `initial={isHydrated ? { y: 50, opacity: 0 } : false}` + `key={isHydrated ? "animated" : "static"}`
- `motion.div` (scroll indicator outer): `initial={isHydrated ? { opacity: 0 } : false}` + `key={isHydrated ? "animated" : "static"}`
- Do NOT change `motion.section` (the outer wrapper) -- its `style={{ scale: heroScale, opacity: heroOpacity }}` is scroll-driven, not entrance animation
- Do NOT change the inner `motion.div` with `animate={{ y: [0, 10, 0] }}` (infinite bounce, no `initial`)

**about-section.tsx** (4 elements):

- `motion.span` ("About" label): `initial={isHydrated ? { opacity: 0 } : false}` + `key={isHydrated ? "animated" : "static"}`
- `motion.h2`: `initial={isHydrated ? { y: 50, opacity: 0 } : false}` + `key={isHydrated ? "animated" : "static"}`
- `motion.p` (first paragraph): `initial={isHydrated ? { y: 30, opacity: 0 } : false}` + `key={isHydrated ? "animated" : "static"}`
- `motion.p` (second paragraph): `initial={isHydrated ? { y: 30, opacity: 0 } : false}` + `key={isHydrated ? "animated" : "static"}`

**metrics-section.tsx** (1 element per metric, rendered in a map):

- `motion.div` (metric card): `initial={isHydrated ? { opacity: 0, y: 50 } : false}` + `key={isHydrated ? \`animated-${metric.id}\` : metric.id}`Note: Since this is inside a`.map()`, preserve the unique key by incorporating `metric.id` in both branches.

**experience-timeline.tsx** (1 element per experience, rendered in a map):

- `motion.div` (timeline item): `initial={isHydrated ? { opacity: 0, x: -30 } : false}` + `key={isHydrated ? \`animated-${item.id}\` : item.id}`
  Note: Same map key pattern as metrics.

**tech-stack-section.tsx** (2 types of elements, rendered in nested maps):

- `motion.h3` (category header): `initial={isHydrated ? { x: -30, opacity: 0 } : false}` + `key={isHydrated ? \`animated-${category.name}\` : category.name}`
- `motion.div` (tech icon item): `initial={isHydrated ? { opacity: 0, y: 6 } : false}` + `key={isHydrated ? \`animated-${tech.name}\` : tech.name}`

**graph-section.tsx** (1 element inside GraphSectionInner):

- `motion.div` (graph container): `initial={isHydrated ? { opacity: 0, scale: 0.98 } : false}` + `key={isHydrated ? "animated" : "static"}`
  Note: This element also has `ref={graphContainerRef}` and `onMouseEnter={handleGraphEnter}`. The ref will re-attach after remount since React handles ref reassignment on key changes. Verify the ResizeObserver effect re-fires after remount (it will, because the useEffect depends on the ref being set).

### CRITICAL CONSTRAINTS:

- Do NOT remove framer-motion imports or change animation end states (`animate`, `whileInView` props stay exactly as they are)
- Do NOT change `transition` props
- Do NOT change `viewport` props
- Do NOT add/remove `"use client"` directives
- Do NOT change any CSS classes or non-animation props
- The ONLY changes are: (1) `initial` prop becomes conditional, (2) `key` prop added for remount
  </action>
  <verify>

1. Run `npm run build` -- must succeed with zero errors
2. Run `npm run dev` and view-source: on the page -- verify sections have visible content (no inline `style="opacity: 0"` on section content elements)
3. Grep for `initial={{` across all modified files to confirm every instance is now conditional on `isHydrated`
4. Grep for `useHydrated` in all modified files to confirm import and usage
5. Run `grep -rn 'initial={' components/sections/ | grep -v 'isHydrated'` should return zero results (except the scroll-driven motion.section in hero which is unchanged)
   </verify>
   <done>

- All 12 motion elements across 6 section components use hydration-aware `initial` prop
- SSR HTML has no `style="opacity: 0"` on animated elements (content visible in PPR shell)
- `useHydrated` hook exists at `lib/use-hydrated.ts` and is imported by all 6 components
- After hydration, entrance animations still play (verified by scrolling through the page)
- Build passes with zero errors
  </done>
  </task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Hydration-aware initial states for all framer-motion elements so PPR shell shows visible content</what-built>
  <how-to-verify>
1. Run `npm run dev` and open the page
2. Open DevTools Network tab, throttle to "Slow 3G" or "Fast 3G"
3. Hard reload the page (Cmd+Shift+R)
4. **Verify PPR shell visibility:** During the loading period (before JS hydrates), sections should show visible content -- text, headings, icons should all be readable, NOT hidden behind transparent/invisible states
5. **Verify entrance animations still work:** After hydration completes, scroll down through the page. Below-fold sections (about, metrics, timeline, tech stack, graph) should animate in with their entrance effects (fade, slide) as you scroll them into view
6. **Verify hero:** The hero section (MANNAN text, orange bar, subtitle) should be visible immediately in the PPR shell, and after hydration the entrance animation should play smoothly
7. **Verify no flash:** Watch carefully during hydration -- there should be no jarring flash of content disappearing and reappearing. The transition should be imperceptible or at most a single-frame flicker
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with visibility or animation behavior</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. View page source shows section content without inline `opacity: 0` styles
3. On slow network throttle, PPR shell renders visible content before JS loads
4. After hydration, entrance animations play for below-fold content
5. No visible flash of content disappearing during hydration
6. All existing animations (scroll parallax, whileInView, infinite bounce) work identically to before
</verification>

<success_criteria>

1. PPR static shell shows all section content visibly (hero, about, metrics, timeline, tech stack all readable before JS loads)
2. Entrance animations preserved -- below-fold sections fade/slide in on scroll after hydration
3. Zero build errors
4. No visual regression in animation behavior
   </success_criteria>

<output>
After completion, create `.planning/phases/12-ppr-image-optimization/12-03-SUMMARY.md`
</output>
