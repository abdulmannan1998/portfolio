---
phase: 09-animation-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/globals.css
  - hooks/use-scroll-animation.ts
autonomous: true

must_haves:
  truths:
    - "CSS keyframe animations (fade-in-up, fade-in-down, fade-in-left, scale-in) are defined in globals.css and can be applied to any element via class names"
    - "A test element with animation-timeline: view() animates on scroll in Chrome"
    - "An Intersection Observer polyfill activates the same animation in Safari/Firefox"
    - "Reduced motion users see opacity-only fades instead of transform-based animations"
  artifacts:
    - path: "app/globals.css"
      provides: "CSS keyframe definitions and scroll-driven animation utility classes"
      contains: "@keyframes fade-in-up"
    - path: "hooks/use-scroll-animation.ts"
      provides: "Intersection Observer polyfill hook for browsers without animation-timeline support"
      exports: ["useScrollAnimation"]
  key_links:
    - from: "app/globals.css"
      to: "animation-timeline: view()"
      via: "CSS utility classes use scroll-driven animation timeline"
      pattern: "animation-timeline:\\s*view\\(\\)"
    - from: "hooks/use-scroll-animation.ts"
      to: "CSS .animate class"
      via: "IO adds 'animate' class which triggers animation-play-state: running"
      pattern: "classList\\.add.*animate"
    - from: "app/globals.css"
      to: "@media (prefers-reduced-motion: reduce)"
      via: "Reduced motion media query replaces transforms with opacity-only fades"
      pattern: "prefers-reduced-motion"
---

<objective>
Define CSS keyframe animation infrastructure (fade-in-up, fade-in-down, fade-in-left, scale-in) in globals.css with scroll-driven animation triggers, and create an Intersection Observer polyfill hook for browsers that lack animation-timeline support.

Purpose: This creates the animation foundation that Phases 10-12 will use to replace framer-motion entrance animations with CSS. Without this infrastructure, section migration cannot begin.
Output: Four CSS keyframe animations as utility classes in globals.css, a useScrollAnimation hook in hooks/, and reduced-motion accessibility support.
</objective>

<execution_context>
@/Users/sunny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-animation-foundation/09-CONTEXT.md
@.planning/phases/09-animation-foundation/09-RESEARCH.md
@app/globals.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define CSS keyframe animations and scroll-driven utility classes</name>
  <files>app/globals.css</files>
  <action>
Add the following to globals.css AFTER the existing preloader animations section:

1. Four @keyframes definitions:
   - `fade-in-up`: opacity 0 + translateY(2rem) -> opacity 1 + translateY(0)
   - `fade-in-down`: opacity 0 + translateY(-2rem) -> opacity 1 + translateY(0)
   - `fade-in-left`: opacity 0 + translateX(-2rem) -> opacity 1 + translateX(0)
   - `scale-in`: opacity 0 + scale(0.8) -> opacity 1 + scale(1)

2. Four utility classes (`.fade-in-up`, `.fade-in-down`, `.fade-in-left`, `.scale-in`) that:
   - Use the corresponding keyframe animation
   - Duration: 0.6s for fades, 0.5s for scale-in
   - Easing: ease-out
   - Fill mode: both
   - Start PAUSED (`animation-play-state: paused`) -- this is critical for the polyfill pattern
   - Set `animation-timeline: view()` AFTER the animation shorthand (shorthand resets timeline)
   - Set `animation-range: entry 0% cover 30%`

3. Polyfill trigger rule: `.fade-in-up.animate, .fade-in-down.animate, .fade-in-left.animate, .scale-in.animate` sets `animation-play-state: running`. This is how the IO polyfill triggers animations in non-supporting browsers.

4. Stagger support: Each utility class includes `animation-delay: calc(var(--stagger-index, 0) * 0.1s)` for optional stagger via CSS custom property.

5. Reduced motion: `@media (prefers-reduced-motion: reduce)` block that replaces all four animation classes with a `fade-only` keyframe (opacity 0 -> 1, no transforms). Set animation-duration to 0.4s for snappier reduced-motion experience.

IMPORTANT pitfall from research: Define `animation-timeline` AFTER the `animation` shorthand. The shorthand resets `animation-timeline`. Use longhand properties to avoid this:

```css
.fade-in-up {
  animation-name: fade-in-up;
  animation-duration: 0.6s;
  animation-timing-function: ease-out;
  animation-fill-mode: both;
  animation-play-state: paused;
  animation-timeline: view();
  animation-range: entry 0% cover 30%;
  animation-delay: calc(var(--stagger-index, 0) * 0.1s);
}
```

Do NOT use the `animation` shorthand -- use longhand properties to prevent timeline reset issues.
</action>
<verify>
Run `npx next build` to confirm no CSS syntax errors. Grep globals.css for all four keyframe names and animation-timeline to confirm they exist.
</verify>
<done>
globals.css contains four @keyframes definitions, four utility classes with animation-timeline: view() and animation-range, polyfill .animate trigger rules, stagger support via --stagger-index, and a prefers-reduced-motion block with opacity-only fades.
</done>
</task>

<task type="auto">
  <name>Task 2: Create Intersection Observer polyfill hook</name>
  <files>hooks/use-scroll-animation.ts</files>
  <action>
Create `hooks/use-scroll-animation.ts` exporting a `useScrollAnimation` hook.

The hook:

1. Accepts a `RefObject<HTMLElement | null>` and optional config: `{ threshold?: number; rootMargin?: string; once?: boolean }`
2. On mount, feature-detect `CSS.supports('animation-timeline: view()')`. If native support exists, return early -- the CSS handles everything.
3. If no native support, create an IntersectionObserver that:
   - Observes the ref element
   - On intersection (`entry.isIntersecting`): adds `'animate'` class to `entry.target`
   - If `once` is true (default true): unobserves after first trigger
   - If `once` is false: removes `'animate'` class when element exits viewport
   - Default threshold: 0.1
   - Default rootMargin: `'0px 0px -10% 0px'` (negative bottom margin triggers slightly before full entry, per research pitfall #5)
4. Cleanup: disconnect observer on unmount
5. Dependency array: `[ref, options?.threshold, options?.rootMargin, options?.once]` -- use individual option values, not the options object, to avoid re-creating observer on every render

Also export a standalone `initScrollAnimations` function (non-hook) that:

1. Feature-detects animation-timeline support
2. If not supported, creates a single IntersectionObserver that observes ALL elements matching `.fade-in-up, .fade-in-down, .fade-in-left, .scale-in` selectors
3. Adds `'animate'` class on intersection, unobserves after trigger
4. Returns a cleanup function that disconnects the observer

This standalone function is useful for Phase 10-12 where sections may not use React refs but need polyfill behavior. It can be called once from a layout-level client component.

IMPORTANT: The hook must handle the case where `ref.current` is null on first render (common with SSR). Guard all observer operations behind `if (!element) return`.
</action>
<verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify the file exports both `useScrollAnimation` and `initScrollAnimations`.
</verify>
<done>
hooks/use-scroll-animation.ts exists, exports useScrollAnimation hook and initScrollAnimations function, feature-detects animation-timeline support, uses IntersectionObserver as fallback with proper cleanup, and handles null refs safely.
</done>
</task>

</tasks>

<verification>
1. `npx next build` completes without errors
2. globals.css contains `@keyframes fade-in-up`, `@keyframes fade-in-down`, `@keyframes fade-in-left`, `@keyframes scale-in`
3. globals.css contains `animation-timeline: view()` on all four utility classes
4. globals.css contains `@media (prefers-reduced-motion: reduce)` block
5. globals.css contains `.animate` trigger rules for polyfill
6. hooks/use-scroll-animation.ts exports useScrollAnimation and initScrollAnimations
7. TypeScript compiles with no errors
</verification>

<success_criteria>

- Four CSS keyframe animations are available as utility classes (.fade-in-up, .fade-in-down, .fade-in-left, .scale-in)
- Animation-timeline: view() is set on each class for native scroll-driven behavior in Chrome
- IO polyfill hook exists for Firefox/Safari fallback
- Reduced-motion users get opacity-only fades
- Stagger support available via --stagger-index CSS variable
- Build passes with no errors
  </success_criteria>

<output>
After completion, create `.planning/phases/09-animation-foundation/09-01-SUMMARY.md`
</output>
