---
phase: 09-animation-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - components/hero-parallax.tsx
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "Hero section parallax scroll effect works identically to current behavior (scale 1->0.8, opacity 1->0 over first 15% of scroll)"
    - "Hero parallax scroll logic lives in its own client wrapper component, not in page.tsx"
    - "Hero wrapper accepts server-rendered children via children prop"
    - "page.tsx still renders all hero content (name, title, scroll indicator, twinkling stars) but inside the new wrapper"
  artifacts:
    - path: "components/hero-parallax.tsx"
      provides: "Client wrapper component for hero parallax scroll effect"
      exports: ["HeroParallax"]
      contains: "use client"
    - path: "app/page.tsx"
      provides: "Main page using HeroParallax wrapper instead of inline framer-motion scroll"
      contains: "HeroParallax"
  key_links:
    - from: "components/hero-parallax.tsx"
      to: "window scroll event"
      via: "passive scroll listener with requestAnimationFrame throttle"
      pattern: "addEventListener.*scroll.*passive"
    - from: "components/hero-parallax.tsx"
      to: "GPU-accelerated transform"
      via: "Direct DOM style manipulation (transform + opacity)"
      pattern: "style\\.transform.*scale"
    - from: "app/page.tsx"
      to: "components/hero-parallax.tsx"
      via: "HeroParallax wraps hero section children"
      pattern: "<HeroParallax>"
---

<objective>
Extract hero parallax scroll logic from page.tsx into a dedicated HeroParallax client wrapper component that accepts server-rendered children, replacing framer-motion useScroll/useTransform with requestAnimationFrame-based direct DOM manipulation.

Purpose: Isolating the parallax scroll logic into its own client boundary is the critical prerequisite for making page.tsx a server component in Phase 13. The hero section currently forces the entire page to be "use client" because of framer-motion scroll hooks. This extraction breaks that dependency.
Output: A new HeroParallax component and an updated page.tsx that uses it.
</objective>

<execution_context>
@/Users/sunny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-animation-foundation/09-CONTEXT.md
@.planning/phases/09-animation-foundation/09-RESEARCH.md
@app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HeroParallax client wrapper component</name>
  <files>components/hero-parallax.tsx</files>
  <action>
Create `components/hero-parallax.tsx` with `'use client'` directive.

The component:

1. Exports `HeroParallax` accepting `{ children: React.ReactNode }`
2. Uses a `useRef<HTMLElement>(null)` for the section element
3. On mount, sets up a passive scroll event listener with requestAnimationFrame throttle pattern:
   - Track `ticking` flag to prevent multiple rAF callbacks per frame
   - On scroll: if not ticking, call `requestAnimationFrame(updateParallax)` and set ticking = true
   - `updateParallax` calculates:
     - `scrolled = window.scrollY`
     - `maxScroll = window.innerHeight * 0.15` (matches current framer-motion [0, 0.15] range from useScroll)
     - `progress = Math.min(scrolled / maxScroll, 1)` (clamp to 0-1)
     - `scale = 1 - progress * 0.2` (1.0 at top, 0.8 at maxScroll -- matches current heroScale)
     - `opacity = 1 - progress` (1.0 at top, 0.0 at maxScroll -- matches current heroOpacity)
   - Apply via direct DOM: `hero.style.transform = \`scale(${scale})\``; `hero.style.opacity = \`${opacity}\``
   - Set ticking = false after update

4. Call `updateParallax()` once on mount to set initial state (handles page refreshed mid-scroll)
5. Cleanup: remove scroll event listener on unmount
6. Render: `<section ref={heroRef} className="sticky top-0 min-h-screen flex flex-col justify-center items-center px-6 bg-black">{children}</section>`

IMPORTANT: The className on the section must match the current hero section classes from page.tsx: `sticky top-0 min-h-screen flex flex-col justify-center items-center px-6 bg-black`. The current motion.section uses these exact classes.

NOTE: The current page.tsx uses `containerRef` on the `<main>` element and `useScroll({ target: containerRef })` which tracks scroll progress of the main container. The replacement uses `window.scrollY` directly, which is equivalent since main is the scrolling container. The `[0, 0.15]` range on scrollYProgress maps to "first 15% of the container's scroll height." Since the container is roughly viewport-height tall in the hero region, `window.innerHeight * 0.15` approximates this threshold. This may need slight tuning -- start with 0.15 and the parallax should feel identical.
</action>
<verify>
Run `npx tsc --noEmit` to confirm the component type-checks. Verify the file has 'use client' directive and exports HeroParallax.
</verify>
<done>
components/hero-parallax.tsx exists with 'use client' directive, exports HeroParallax component that accepts children prop, uses requestAnimationFrame + passive scroll listener for parallax, applies scale (1->0.8) and opacity (1->0) transforms matching current framer-motion behavior.
</done>
</task>

<task type="auto">
  <name>Task 2: Refactor page.tsx to use HeroParallax wrapper</name>
  <files>app/page.tsx</files>
  <action>
Update page.tsx to replace the framer-motion hero parallax with the new HeroParallax wrapper.

Changes:

1. Add import: `import { HeroParallax } from "@/components/hero-parallax";`
2. REMOVE these framer-motion imports that are ONLY used for hero parallax: `useScroll`, `useTransform`. Keep the `motion` import -- it is still used for hero entrance animations (motion.h1, motion.div, motion.p) and the about section (motion.span, motion.h2, motion.p with whileInView).
3. REMOVE `useRef` import if it is no longer used elsewhere in page.tsx. Check: `containerRef` is the only ref. If removing containerRef means useRef is unused, remove the import.
4. REMOVE `const containerRef = useRef<HTMLDivElement>(null)`
5. REMOVE `const { scrollYProgress } = useScroll({ target: containerRef })`
6. REMOVE `const heroScale = useTransform(scrollYProgress, [0, 0.15], [1, 0.8])`
7. REMOVE `const heroOpacity = useTransform(scrollYProgress, [0, 0.15], [1, 0])`
8. On the `<main>` element: remove `ref={containerRef}` (no longer needed)
9. Replace the hero `<motion.section style={{ scale: heroScale, opacity: heroOpacity }} className="sticky top-0 min-h-screen flex flex-col justify-center items-center px-6 bg-black">` with `<HeroParallax>`. The className moves to HeroParallax (already included in Task 1).
10. The hero CHILDREN stay in page.tsx inside `<HeroParallax>`:
    - TwinklingStars
    - The h1 with "MANNAN" (still uses motion.h1 for initial entrance animation -- this is fine, it will be migrated in Phase 10)
    - The orange line motion.div
    - The subtitle motion.p
    - The scroll indicator motion.div

So the structure becomes:

```tsx
<HeroParallax>
  <TwinklingStars />
  {/* Giant name */}
  <div className="relative">
    <motion.h1 ...>MANNAN</motion.h1>
    <motion.div ... /> {/* orange line */}
  </div>
  <motion.p ...>SENIOR SOFTWARE ENGINEER</motion.p>
  {/* Scroll indicator */}
  <motion.div ...>
    <motion.div ... /> {/* bouncing line */}
  </motion.div>
</HeroParallax>
```

11. Verify the `motion` import is still needed (it IS -- hero entrance animations and about section still use motion.\*). Do NOT remove it.
12. Update the framer-motion import line to only import what is still used: `import { motion } from "framer-motion"` (remove useScroll and useTransform from the import).

IMPORTANT: Do NOT touch any other sections (about, marquee, metrics, tech, experience, graph, footer). Only the hero section and its related scroll hooks change.
</action>
<verify>

1. Run `npx next build` to confirm build succeeds
2. Run `npx next dev` and verify in browser:
   - Hero section scrolls with scale + opacity parallax effect
   - Hero entrance animations (name slide up, orange line, subtitle) still play on load
   - All other sections render correctly
   - Scroll indicator still bounces
3. Grep page.tsx to confirm useScroll and useTransform are no longer imported
4. Grep page.tsx to confirm containerRef is removed
   </verify>
   <done>
   page.tsx uses HeroParallax wrapper for hero section, framer-motion useScroll/useTransform removed, containerRef removed, hero children remain in page.tsx as server-renderable content inside the client wrapper, all other sections unchanged, build passes.
   </done>
   </task>

</tasks>

<verification>
1. `npx next build` completes without errors
2. Hero parallax scroll effect (scale 1->0.8, opacity 1->0) works in browser
3. Hero entrance animations still play (framer-motion motion.h1, motion.p still used for those)
4. About section whileInView animations still work
5. All other sections render and function identically
6. page.tsx no longer imports useScroll or useTransform from framer-motion
7. page.tsx no longer has containerRef
8. components/hero-parallax.tsx has 'use client' directive
9. HeroParallax accepts children prop (server-renderable content pattern)
</verification>

<success_criteria>

- Hero parallax scroll effect matches current behavior (scale down + fade out on scroll)
- Scroll logic lives in components/hero-parallax.tsx, not page.tsx
- HeroParallax accepts children (ready for RSC migration in Phase 13)
- page.tsx has fewer framer-motion imports (useScroll, useTransform removed)
- No visual regression in any section
- Build passes
  </success_criteria>

<output>
After completion, create `.planning/phases/09-animation-foundation/09-02-SUMMARY.md`
</output>
