---
phase: 09-server-side-github-fetching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/github.ts
  - components/github-activity.tsx
  - components/sections/tech-and-code-section.tsx
  - components/page-content.tsx
  - app/page.tsx
  - app/api/github/route.ts
autonomous: true

must_haves:
  truths:
    - "GitHub activity section shows real data on first paint with zero loading spinners or skeleton flash"
    - "GitHubActivity component is purely presentational -- receives commits as props, contains no fetch or cache logic"
    - "No module-level Map cache exists in github-activity.tsx"
    - "Server-side fetch function exists in lib/github.ts with ISR revalidation (5 min)"
    - "API route delegates to shared fetchGitHubCommits function"
    - "GitHub activity section still renders commits with correct styling after refactor"
    - "page.tsx is a server component that fetches GitHub data and passes it to a client PageContent component"
  artifacts:
    - path: "lib/github.ts"
      provides: "Server-side GitHub fetch function and RedactedCommit type"
      exports: ["fetchGitHubCommits", "RedactedCommit"]
    - path: "components/github-activity.tsx"
      provides: "Presentational GitHub activity renderer"
      contains: "commits: RedactedCommit[] in props"
    - path: "components/page-content.tsx"
      provides: "Client component with all page UI, framer-motion, useRef/useScroll"
      contains: '"use client"'
    - path: "app/page.tsx"
      provides: "Server component wrapper that fetches data and renders PageContent"
      contains: "async function Page"
    - path: "app/api/github/route.ts"
      provides: "Thin API route delegating to lib/github.ts"
  key_links:
    - from: "lib/github.ts"
      to: "GitHub Events API"
      via: "server-side fetch with next revalidate"
      pattern: "fetch.*api\\.github\\.com.*next.*revalidate"
    - from: "app/page.tsx"
      to: "lib/github.ts"
      via: "server-side import and async call"
      pattern: "const commits = await fetchGitHubCommits"
    - from: "app/page.tsx"
      to: "components/page-content.tsx"
      via: "passing commits as prop to client component"
      pattern: "<PageContent commits=\\{commits\\}"
    - from: "components/page-content.tsx"
      to: "components/sections/tech-and-code-section.tsx"
      via: "passing commits as prop"
      pattern: "<TechAndCodeSection commits=\\{commits\\}"
    - from: "components/sections/tech-and-code-section.tsx"
      to: "components/github-activity.tsx"
      via: "passing commits as prop"
      pattern: "<GitHubActivity commits=\\{commits\\}"
    - from: "app/api/github/route.ts"
      to: "lib/github.ts"
      via: "import and delegation"
      pattern: "import.*fetchGitHubCommits.*from.*lib/github"
---

<objective>
Achieve zero-flash server-side rendering of GitHub activity data with ISR. Extract fetch logic into a shared server function, make page.tsx a server component that fetches data at request time, and push all client-side UI into a new PageContent client component.

Purpose: GitHub activity data loads instantly on first paint with no loading spinner or skeleton flash. The data is fetched on the server via ISR (5-min revalidation), and the GitHubActivity component is purely presentational.

Output: `lib/github.ts` (shared fetch + types), presentational `github-activity.tsx`, server `page.tsx`, client `components/page-content.tsx`, thin API route, and updated `tech-and-code-section.tsx` receiving commits as props.
</objective>

<execution_context>
@/Users/sunny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@app/page.tsx
@app/api/github/route.ts
@components/github-activity.tsx
@components/sections/tech-and-code-section.tsx
@lib/social-links.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared GitHub fetch function and refactor GitHubActivity to presentational</name>
  <files>lib/github.ts, app/api/github/route.ts, components/github-activity.tsx</files>
  <action>
**Part A: Create `lib/github.ts`** by extracting core fetch logic from `app/api/github/route.ts`:

1. Move these items from the route into `lib/github.ts`:
   - `RedactedCommit` type (export it)
   - `GitHubEvent` type
   - `GitHubCommitResponse` type
   - `GITHUB_USERNAME` constant
   - `makeHeaders()` function

2. Create and export an async `fetchGitHubCommits()` function containing the fetch logic currently inside the route's `GET()` handler. Key differences from the route version:
   - All `fetch()` calls use `{ next: { revalidate: 300 } }` instead of `{ cache: "no-store" }` -- this tells Next.js to cache and revalidate every 5 minutes via ISR
   - Return type is `RedactedCommit[]` (not NextResponse)
   - On any error (API failure, network error), return `[]` for graceful degradation
   - Log errors to console.error just like the current route does

3. Simplify `app/api/github/route.ts`:
   - Import `fetchGitHubCommits` from `@/lib/github`
   - The `GET()` handler becomes: call `fetchGitHubCommits()`, wrap result in `NextResponse.json({ commits })`
   - Keep the `Cache-Control: public, s-maxage=300, stale-while-revalidate=600` headers on the response
   - Remove all moved types/constants/functions -- the route should be ~15 lines

**Part B: Refactor `components/github-activity.tsx` to be purely presentational:**

1. Remove the `"use client"` directive from the top of the file.

2. Remove these imports: `useState`, `useEffect`.

3. Delete ALL caching code (lines 23-51 in current file):
   - `CacheEntry` type
   - `commitCache` Map
   - `CACHE_TTL` constant
   - `getCachedCommits()` function
   - `setCachedCommits()` function

4. Delete the duplicate `RedactedCommit` type definition. Import it from `@/lib/github` instead.

5. Change `GitHubActivityProps` to:

   ```typescript
   export type GitHubActivityProps = {
     commits: RedactedCommit[];
     username: string;
   };
   ```

   Both props are required.

6. Remove the `loading` and `error` state declarations. Remove the entire `useEffect` block (the fetch-on-mount logic).

7. Simplify the JSX render:
   - Remove the loading skeleton branch (`loading ? <div className="space-y-4">...`)
   - Remove the error branch (`error ? <p>...`)
   - Keep only: the header (with LIVE badge checking `commits.length > 0`), the empty state (`commits.length === 0`), and the commits list
   - The component signature becomes `export function GitHubActivity({ commits, username }: GitHubActivityProps)`

8. Keep `formatTimeAgo()` and `Redacted` sub-component unchanged -- they are pure functions/components with no client APIs.
   </action>
   <verify>
   Run `npx tsc --noEmit` -- no type errors. Confirm `lib/github.ts` exports `fetchGitHubCommits` and `RedactedCommit`. Confirm `app/api/github/route.ts` is a thin wrapper. Confirm github-activity.tsx has no "use client", no useState/useEffect, no Map cache.
   </verify>
   <done>lib/github.ts exists with fetchGitHubCommits() using ISR revalidation. API route is a thin wrapper. GitHubActivity is purely presentational with props-based interface. No duplicate type definitions.</done>
   </task>

<task type="auto">
  <name>Task 2: Split page.tsx into server wrapper + client PageContent, wire server-fetched data through props</name>
  <files>app/page.tsx, components/page-content.tsx, components/sections/tech-and-code-section.tsx</files>
  <action>
**The zero-flash architecture:** page.tsx becomes a server component that fetches GitHub data at request time (with ISR), then passes it to a client PageContent component. This eliminates the loading flash because the HTML already contains the real data when it arrives at the browser.

**Step 1: Create `components/page-content.tsx`** -- the client component:

1. Move ALL the current content of `app/page.tsx` into this new file.
2. Keep the `"use client"` directive at the top.
3. Keep ALL existing imports: `useRef`, `dynamic`, `motion`, `useScroll`, `useTransform`, `Link`, icons, `MarqueeText`, `ExperienceTimeline`, `MetricsSection`, `TechAndCodeSection`, `SOCIAL_LINKS`, `TwinklingStars`, `mulberry32`.
4. Keep the `GraphSection` dynamic import, `bgRandom`, and `backgroundPattern` exactly as they are.
5. Rename the component to `PageContent` and export it as a named export.
6. Add a `commits` prop:

   ```typescript
   import type { RedactedCommit } from "@/lib/github";

   type PageContentProps = {
     commits: RedactedCommit[];
   };

   export function PageContent({ commits }: PageContentProps) {
     // ... existing page content
   ```

7. Pass `commits` down to `TechAndCodeSection`:

   ```tsx
   <TechAndCodeSection commits={commits} />
   ```

   Everything else in the JSX stays exactly the same.

**Step 2: Rewrite `app/page.tsx`** as a server component:

Replace the entire file with:

```typescript
import { fetchGitHubCommits } from "@/lib/github";
import { PageContent } from "@/components/page-content";

export const revalidate = 300; // ISR: revalidate every 5 minutes

export default async function Page() {
  const commits = await fetchGitHubCommits();
  return <PageContent commits={commits} />;
}
```

Key points:

- NO `"use client"` directive -- this is a server component
- `async function Page` -- server components can be async
- `export const revalidate = 300` -- page-level ISR matching the fetch-level ISR
- The page fetches data on the server, then passes it as a serializable prop to the client component

**Step 3: Update `components/sections/tech-and-code-section.tsx`** to accept commits as a prop:

1. Add a `commits` prop to the component:

   ```typescript
   import type { RedactedCommit } from "@/lib/github";

   type TechAndCodeSectionProps = {
     commits: RedactedCommit[];
   };

   export function TechAndCodeSection({ commits }: TechAndCodeSectionProps) {
   ```

2. Pass commits down to GitHubActivity:

   ```tsx
   <GitHubActivity commits={commits} username={SOCIAL_LINKS.github.username} />
   ```

3. Do NOT add useState, useEffect, or any fetch logic. The data flows from server -> PageContent -> TechAndCodeSection -> GitHubActivity as props.

**Data flow summary:**

```
Server: page.tsx (async, fetches data via ISR)
  -> Client: PageContent (receives commits prop)
    -> Client: TechAndCodeSection (receives commits prop)
      -> Presentational: GitHubActivity (receives commits prop, renders them)
```

**Why this achieves zero-flash:** The server renders the full HTML with real GitHub data embedded. The browser receives pre-rendered HTML with commits already visible. No useEffect, no loading state, no skeleton -- data is there on first paint.

**Note about Phase 10/11 impact:** This plan makes page.tsx a server component earlier than Phase 11 originally planned. Phase 11 can now focus on extracting remaining client boundaries (hero animations, about section, etc.) rather than the page.tsx conversion. The roadmap description for Phase 11 ("Remove 'use client' from page.tsx") is achieved here as a necessary step for zero-flash.
</action>
<verify>

1. Run `npm run build` -- build succeeds with no errors.
2. Verify page.tsx is a server component: `grep -c "use client" app/page.tsx` returns 0.
3. Verify page.tsx is async: `grep "async function Page" app/page.tsx` matches.
4. Verify PageContent is a client component: `grep "use client" components/page-content.tsx` matches.
5. Verify NO useEffect fetch in tech-and-code-section.tsx: `grep -c "useEffect\|useState\|fetch(" components/sections/tech-and-code-section.tsx` returns 0.
6. Verify NO useEffect fetch in github-activity.tsx: `grep -c "useEffect\|useState" components/github-activity.tsx` returns 0.
7. Run `npm run dev`, visit the page. View source (Ctrl+U) and confirm the GitHub commits HTML is present in the initial server response -- this proves zero-flash.
   </verify>
   <done>page.tsx is a server component that async-fetches GitHub data via ISR. PageContent client component receives data as props. TechAndCodeSection and GitHubActivity receive commits as props with no fetch logic. GitHub data is present in the initial HTML response -- zero loading flash.</done>
   </task>

</tasks>

<verification>
After both tasks complete, verify all requirements:

1. **DATA-01:** `lib/github.ts` exports `fetchGitHubCommits` called from server component page.tsx -- `grep "await fetchGitHubCommits" app/page.tsx`
2. **DATA-02:** ISR configured at both fetch and page level -- `grep "revalidate.*300" lib/github.ts app/page.tsx`
3. **DATA-03:** No module-level cache -- `grep -c "new Map\|commitCache" components/github-activity.tsx` returns 0
4. **DATA-04:** Presentational component -- `grep "commits: RedactedCommit" components/github-activity.tsx` shows props-based interface
5. **Zero-flash:** View page source in browser -- GitHub commits HTML is present in the initial server response (no loading skeleton in the HTML)
6. **Build passes:** `npm run build` succeeds
7. **No visual regression:** GitHub activity section displays commits with correct styling
   </verification>

<success_criteria>

- page.tsx has no "use client" directive and is an async server component
- page.tsx calls fetchGitHubCommits() and passes result to PageContent
- export const revalidate = 300 is set in page.tsx for ISR
- components/page-content.tsx has "use client" and contains all the previous page.tsx UI
- lib/github.ts exports fetchGitHubCommits() with { next: { revalidate: 300 } }
- lib/github.ts exports RedactedCommit type as single source of truth
- components/github-activity.tsx has no "use client", no useState/useEffect, no Map cache, no fetch logic
- components/github-activity.tsx accepts { commits: RedactedCommit[]; username: string } as props
- components/sections/tech-and-code-section.tsx accepts commits as a prop and passes it to GitHubActivity (no fetch logic)
- app/api/github/route.ts is a thin wrapper delegating to fetchGitHubCommits()
- Build succeeds with no type errors
- GitHub commits are present in the server-rendered HTML (zero loading flash)
  </success_criteria>

<output>
After completion, create `.planning/phases/09-server-side-github-fetching/09-01-SUMMARY.md`
</output>
