---
phase: 08-technical-debt
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/debounce.ts
  - components/sections/graph-section.tsx
autonomous: true

must_haves:
  truths:
    - "Debounce function has .cancel() method that clears pending timeout"
    - "All setTimeout calls in graph reveal are tracked and cleaned up on unmount"
    - "Component unmount during animation sequence does not leave orphan timers"
  artifacts:
    - path: "lib/debounce.ts"
      provides: "Debounce utility with cleanup"
      exports: ["debounce"]
      contains: ".cancel"
    - path: "components/sections/graph-section.tsx"
      provides: "Graph section with timer cleanup"
      contains: "timersRef"
  key_links:
    - from: "components/sections/graph-section.tsx"
      to: "lib/debounce.ts"
      via: "debouncedFitView.cancel()"
      pattern: "debouncedFitView\\.cancel"
    - from: "components/sections/graph-section.tsx"
      to: "useEffect cleanup"
      via: "timersRef.current.forEach(clearTimeout)"
      pattern: "timersRef\\.current\\.forEach\\(clearTimeout\\)"
---

<objective>
Fix async cleanup patterns in debounce utility and graph reveal sequence

Purpose: Prevent memory leaks from orphaned timers when components unmount during animations
Output: Debounce with .cancel() method, graph-section with tracked timer cleanup
</objective>

<execution_context>
@/Users/sunny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sunny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-technical-debt/08-RESEARCH.md

@lib/debounce.ts
@components/sections/graph-section.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add .cancel() method to debounce utility</name>
  <files>lib/debounce.ts</files>
  <action>
Update debounce function to return a debounced function with an attached .cancel() method.

Current implementation (11 lines):

- Returns plain function that calls setTimeout
- No way to cancel pending timeout

New implementation pattern from RESEARCH.md:

```typescript
export function debounce<T extends (...args: unknown[]) => unknown>(
  func: T,
  wait: number,
): ((...args: Parameters<T>) => void) & { cancel: () => void } {
  let timeout: NodeJS.Timeout | null = null;

  const debounced = (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };

  debounced.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounced;
}
```

Key changes:

- Return type now includes `& { cancel: () => void }`
- Add `debounced.cancel` method that clears timeout
- Set timeout to null after clearing for clean state
  </action>
  <verify>

1. TypeScript compiles: `npx tsc --noEmit lib/debounce.ts`
2. Verify .cancel exists: grep "\.cancel" lib/debounce.ts
   </verify>
   <done>debounce returns function with .cancel() method that clears pending timeout</done>
   </task>

<task type="auto">
  <name>Task 2: Add timer cleanup to graph reveal sequence</name>
  <files>components/sections/graph-section.tsx</files>
  <action>
Add cleanup for all setTimeout calls in startRevealSequence and other callbacks.

Current issues (from RESEARCH.md analysis):

- Lines 165-192: startRevealSequence creates 5+ setTimeout calls without tracking
- Line 121: handleNodeHover creates setTimeout without tracking
- Line 151: addNodeAndEdges creates setTimeout without tracking
- debouncedFitView needs cleanup in useEffect

Implementation pattern:

1. Add timersRef to track all timeout IDs:

   ```typescript
   const timersRef = useRef<NodeJS.Timeout[]>([]);
   ```

2. Create helper to push and track timers:

   ```typescript
   const addTimer = useCallback((callback: () => void, delay: number) => {
     const id = setTimeout(callback, delay);
     timersRef.current.push(id);
     return id;
   }, []);
   ```

3. Replace all setTimeout in startRevealSequence with addTimer

4. Replace setTimeout in handleNodeHover (line 121) with addTimer

5. Replace setTimeout in addNodeAndEdges (line 151) with addTimer

6. Add useEffect for cleanup:

   ```typescript
   useEffect(() => {
     return () => {
       timersRef.current.forEach(clearTimeout);
       timersRef.current = [];
       debouncedFitView.cancel();
     };
   }, [debouncedFitView]);
   ```

7. Also call debouncedFitView.cancel() in the existing useEffect cleanup for debouncedFitView (if useMemo deps change)

Locations to update:

- Line 121: setTimeout in handleNodeHover
- Line 151: setTimeout in addNodeAndEdges
- Lines 172-191: All setTimeout in startRevealSequence (5 calls)
  </action>
  <verify>

1. Build passes: `npm run build`
2. Timer tracking exists: `grep -n "timersRef" components/sections/graph-section.tsx`
3. Cleanup exists: `grep -n "forEach(clearTimeout)" components/sections/graph-section.tsx`
4. Cancel called: `grep -n "\.cancel()" components/sections/graph-section.tsx`
   </verify>
   <done>All setTimeout calls tracked in timersRef, cleanup useEffect clears all timers and cancels debounce on unmount</done>
   </task>

</tasks>

<verification>
After completing all tasks:
1. Build passes: `npm run build`
2. No TypeScript errors: `npx tsc --noEmit`
3. Debounce has cancel: `grep "cancel" lib/debounce.ts`
4. Timer cleanup implemented: `grep -c "timersRef" components/sections/graph-section.tsx` returns > 0
5. Test manually: Open site, navigate to graph, quickly navigate away - no console errors
</verification>

<success_criteria>

- [ ] lib/debounce.ts exports function with .cancel() method
- [ ] graph-section.tsx tracks all timers in timersRef
- [ ] Cleanup useEffect clears all tracked timers
- [ ] debouncedFitView.cancel() called on unmount
- [ ] Build passes without errors
      </success_criteria>

<output>
After completion, create `.planning/phases/08-technical-debt/08-01-SUMMARY.md`
</output>
